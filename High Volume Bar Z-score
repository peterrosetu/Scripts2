// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Edward

// ref https://www.tradingview.com/script/0KInGMjR-Candle-Colored-by-Volume-Z-score-Morty/ by M0rty 2022.04.25
// Modified & Added Code by Edward 2025.05.20
// - Calc with BINANCE + COINBASE Vol
// - Show the POC (current chart vol)

//@version=6
indicator('High Volume Bar Z-score', overlay = true, max_bars_back = 4999, max_polylines_count = 100, max_boxes_count = 500, max_labels_count = 500, max_lines_count = 500)

// === Inputs ===
len = input.int(20, 'Z-Score MA Length')
z1 = input.float(1.5, 'Threshold z1', step = 0.1)
z2 = input.float(2.5, 'Threshold z2', step = 0.1)

// --- Up colors ---
color_up_normal = input.color(color.rgb(255, 255, 255, 40), 'normal', inline = 'l2', group = 'Up color')
color_up_large = input.color(color.rgb(91, 156, 246), 'large', inline = 'l2', group = 'Up color')
color_up_extreme = input.color(color.rgb(6, 156, 118), 'extreme', inline = 'l2', group = 'Up color')

// --- Down colors ---
color_down_normal = input.color(color.rgb(255, 255, 255, 100), 'normal', inline = 'l3', group = 'Down color')
color_down_large = input.color(color.rgb(247, 124, 128), 'large', inline = 'l3', group = 'Down color')
color_down_extreme = input.color(color.rgb(236, 64, 122), 'extreme', inline = 'l3', group = 'Down color')
show_poc = input.bool(true, 'Show POC', group = 'Point of Control')

// === Z-score Function ===
f_zscore(src, len) =>
    mean = ta.sma(src, len)
    std = ta.stdev(src, len)
    (src - mean) / std

// === Volume from Other Exchanges ===
vol_binance = request.security("BINANCE:BTCUSDT", timeframe.period, volume)
vol_coinbase = request.security("COINBASE:BTCUSD", timeframe.period, volume)

// === Z-scores ===
z_binance = f_zscore(vol_binance, len)
z_coinbase = f_zscore(vol_coinbase, len)

// === Candle Direction ===
isUp = close >= open

// === External helper function to classify Z-score levels ===
// 1 = normal, 2 = large, 3 = extreme
get_level(z) =>
    z >= z2 ? 3 : z >= z1 ? 2 : z < z1  ? 1 : 0

get_bar_color(z_bin, z_cb, isUp) =>

    level_bin = get_level(z_bin)
    level_cb  = get_level(z_cb)

    max_level = math.max(level_bin, level_cb)
    is_highlight = max_level >= 2
    both_extreme = level_bin == 3 and level_cb == 3

    show_color = isUp ? (both_extreme ? color.yellow : max_level == 3 ? color_up_extreme : max_level == 2 ? color_up_large : max_level == 1 ? color_up_normal : na) : (both_extreme ? color.yellow : max_level == 3 ? color_down_extreme : max_level == 2 ? color_down_large : max_level == 1 ? color_down_normal : na)
    [show_color, is_highlight]

// === Final Bar Colors ===
[color_combined, is_highlight] = get_bar_color(z_binance, z_coinbase, isUp)
barcolor(color_combined, title = "Combined Z-bar")

// -----------------------------------------------------------------------------

[intrabar_highs, intrabar_lows, intrabar_vol] = request.security_lower_tf(syminfo.tickerid, '1', [high, low, volume])

var poc_linestyle = line.style_solid

float intrabar_poc = na

// -----------------------------------------------------------------------------

size = array.size(intrabar_highs)

if size > 0 and is_highlight and show_poc

    array<float> tpo_bins = array.new_float()

    for i = 0 to 900 - 1 by 1
        array.push(tpo_bins, 0)

    inc = (high - low) / 900
    num_vals = array.size(intrabar_highs)
    for i = 0 to 900 - 1 by 1
        bin_bottom = low + i * inc
        bin_top = bin_bottom + inc

        for j = 0 to num_vals - 1 by 1
            intrabar_high = array.get(intrabar_highs, j)
            intrabar_low = array.get(intrabar_lows, j)
            intrabar_volume = array.get(intrabar_vol, j)

            inside_bin = intrabar_high <= bin_top and intrabar_low >= bin_bottom
            spans_bin = intrabar_high > bin_top and intrabar_low < bin_bottom
            up_bin = intrabar_high > bin_bottom and intrabar_high < bin_top and intrabar_low < bin_bottom
            dn_bin = intrabar_low < bin_top and intrabar_low > bin_bottom and intrabar_high > bin_top

            if inside_bin
                current = array.get(tpo_bins, i)
                array.set(tpo_bins, i, current + 1 * intrabar_volume)
            else if spans_bin
                current = array.get(tpo_bins, i)
                val = (bin_top - bin_bottom) / (intrabar_high - intrabar_low) * intrabar_volume
                array.set(tpo_bins, i, current + val)
            else if up_bin
                current = array.get(tpo_bins, i)
                val = (intrabar_high - bin_bottom) / (intrabar_high - intrabar_low) * intrabar_volume
                array.set(tpo_bins, i, current + val)
            else if dn_bin
                current = array.get(tpo_bins, i)
                val = (bin_top - intrabar_low) / (intrabar_high - intrabar_low) * intrabar_volume
                array.set(tpo_bins, i, current + val)

    poc_val = array.max(tpo_bins)
    poc_index = array.indexof(tpo_bins, poc_val)

    intrabar_poc := low + inc * (poc_index + 0.5)
    intrabar_poc

// -----------------------------------------------------------------------------

plot(intrabar_poc, color = color.white, linewidth = 2, style = plot.style_circles, title = 'Intrabar POC')

var array<line> poc_lines = array.new_line()
var array<bool> poc_hit = array.new_bool()
var array<int> poc_index = array.new_int()
var array<float> volume_vals = array.new_float()

if array.size(poc_lines) > 0
    for i = array.size(poc_lines) - 1 to 0 by 1
        temp_line = array.get(poc_lines, i)
        temp_poc_price = line.get_y1(temp_line)
        if low <= temp_poc_price and high >= temp_poc_price and not array.get(poc_hit, i)
            array.set(poc_hit, i, true)
            line.set_color(temp_line, color = color.gray)
            line.set_extend(temp_line, extend = extend.none)
            line.set_x2(temp_line, x = bar_index)

array.unshift(poc_lines, line.new(x1 = bar_index, y1 = intrabar_poc, x2 = bar_index + 1, y2 = intrabar_poc, color = color_combined, style = poc_linestyle, width = 1, extend = extend.none))
array.unshift(poc_hit, false)
array.unshift(poc_index, bar_index)
array.unshift(volume_vals, volume)

if array.size(poc_lines) > 500
    temp_line = array.pop(poc_lines)
    line.delete(temp_line)
    array.pop(poc_hit)
    array.pop(poc_index)
    array.pop(volume_vals)

if array.size(poc_lines) > 0
    for i = 0 to array.size(poc_lines) - 1 by 1
        temp_line = array.get(poc_lines, i)
        if array.get(poc_hit, i) == false
            line.set_x2(temp_line, x = bar_index + 1)
